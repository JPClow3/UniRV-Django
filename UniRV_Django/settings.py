"""
Django settings for UniRV_Django project.

Generated by 'django-admin startproject' using Django 5.2.7.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.2/ref/settings/
"""

import locale
import os
import shutil
import sys
from pathlib import Path

import environ

# Force UTF-8 encoding for Windows compatibility with PostgreSQL
if sys.platform == "win32":
    try:
        locale.setlocale(locale.LC_ALL, "en_US.UTF-8")
    except locale.Error:
        try:
            locale.setlocale(locale.LC_ALL, "C.UTF-8")
        except locale.Error:
            pass

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# django-environ: read .env file and provide typed access to env vars.
env = environ.Env(
    SECRET_KEY=(str, "django-insecure-dev-key-change-in-production"),
    DJANGO_DEBUG=(bool, True),
    ALLOWED_HOSTS=(list, []),
    SITE_URL=(str, "http://localhost:8000"),
    DATABASE_URL=(str, ""),
    REDIS_URL=(str, ""),
    REDIS_HOST=(str, ""),
    REDIS_PORT=(int, 6379),
    REDIS_PASSWORD=(str, ""),
    REDIS_MAX_CONNECTIONS=(int, 50),
    CACHE_VERSION=(int, 1),
    CELERY_BROKER_URL=(str, ""),
    CELERY_RESULT_BACKEND=(str, ""),
    USE_CELERY=(bool, False),
    EMAIL_BACKEND=(str, "django.core.mail.backends.console.EmailBackend"),
    EMAIL_HOST=(str, "localhost"),
    EMAIL_PORT=(int, 587),
    EMAIL_USE_TLS=(bool, True),
    EMAIL_HOST_USER=(str, ""),
    EMAIL_HOST_PASSWORD=(str, ""),
    DEFAULT_FROM_EMAIL=(str, "noreply@agrohub.unirv.edu.br"),
    MAILERSEND_API_TOKEN=(str, ""),
    ANYMAIL_WEBHOOK_SECRET=(str, ""),
    ENABLE_SILK=(bool, False),
    CDN_BASE_URL=(str, ""),
    DJANGO_LOG_LEVEL=(str, "INFO"),
    DJANGO_LOG_TO_FILE=(bool, False),
    DJANGO_LOG_DIR=(str, ""),
    NPM_BIN_PATH=(str, ""),
    TAILWIND_COMPILE_ON_THE_FLY=(bool, False),
    WHITENOISE_MAX_AGE=(int, 0),
    GUNICORN_WORKERS=(int, 0),
    COOKIE_DOMAIN=(str, ""),
    PARTNERS=(list, []),
)

# Read .env file if it exists (won't override existing env vars)
environ.Env.read_env(BASE_DIR / ".env", overwrite=False)

# ---------------------------------------------------------------------------
# Core settings
# ---------------------------------------------------------------------------
SECRET_KEY = env("SECRET_KEY")
DEBUG = env("DJANGO_DEBUG")

# Detect if we're running tests
TESTING = (
    bool(os.environ.get("PYTEST_CURRENT_TEST"))
    or (len(sys.argv) > 1 and (
        sys.argv[1] == "test"
        or "pytest" in sys.argv[0]
        or "unittest" in sys.argv[0]
        or "test" in sys.argv
    ))
)

# Security: explicit ALLOWED_HOSTS
if DEBUG:
    ALLOWED_HOSTS = ["localhost", "127.0.0.1", "[::1]"]
else:
    from django.core.exceptions import ImproperlyConfigured

    _hosts = env("ALLOWED_HOSTS")
    parsed_hosts = [h.strip() for h in _hosts if h.strip()] if _hosts else []
    if not parsed_hosts:
        raise ImproperlyConfigured(
            "ALLOWED_HOSTS environment variable is required in production (DEBUG=False). "
            "Please set ALLOWED_HOSTS with your domain(s). "
            "Example: ALLOWED_HOSTS=example.com,www.example.com"
        )

    # Railway: automatically allow health check host used by Railway's internal health checks.
    # Uses multiple env vars since Railway injects different ones across versions.
    is_railway = any(
        os.environ.get(var)
        for var in (
            "RAILWAY_ENVIRONMENT",
            "RAILWAY_ENVIRONMENT_NAME",
            "RAILWAY_PROJECT_ID",
        )
    )
    if is_railway:
        railway_health_host = "healthcheck.railway.app"
        if railway_health_host not in ALLOWED_HOSTS:
            ALLOWED_HOSTS.append(railway_health_host)

# CSRF Trusted Origins for cross-origin requests
# Required when accessing site from different domains (even subdomains)
if not DEBUG:
    # Generate trusted origins from ALLOWED_HOSTS (excluding localhost/127.0.0.1)
    CSRF_TRUSTED_ORIGINS = [
        f"https://{host}"
        for host in ALLOWED_HOSTS
        if host not in ["localhost", "127.0.0.1", "[::1]"]
    ]


# Application definition

INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "django.contrib.humanize",  # For timesince and other human-readable filters
    "simple_history",  # Audit logging - must be before apps that use it
    "widget_tweaks",  # For form field styling in templates
    "tailwind",
    "theme",  # Tailwind theme app
    "easy_thumbnails",  # Image thumbnails generation
    "django_celery_beat",  # Celery periodic tasks via DB
    "health_check",  # django-health-check core
    "health_check.db",  # DB connectivity check
    "health_check.cache",  # Cache backend check
    "health_check.storage",  # Default file storage check
    "dal",  # django-autocomplete-light core
    "dal_select2",  # django-autocomplete-light Select2 widget
    "anymail",  # Email service provider integration
    "django_cleanup.apps.CleanupConfig",  # Auto-delete orphaned files (must be last)
    "editais.apps.EditaisConfig",
]

# Check if easy-thumbnails is available (optional dependency)
HAS_THUMBNAILS = False
try:
    import easy_thumbnails

    HAS_THUMBNAILS = True
except ImportError:
    # easy-thumbnails not installed, remove from INSTALLED_APPS
    if "easy_thumbnails" in INSTALLED_APPS:
        INSTALLED_APPS.remove("easy_thumbnails")
    pass

# Add django_browser_reload only in DEBUG mode (safe for tests)
if DEBUG:
    try:
        import django_browser_reload  # noqa: F401
    except ImportError:
        django_browser_reload = None
    if django_browser_reload is not None:
        INSTALLED_APPS += ["django_browser_reload"]

# Silk profiling — conditionally enabled via ENABLE_SILK env var (staging only)
ENABLE_SILK = env("ENABLE_SILK")
if ENABLE_SILK:
    INSTALLED_APPS += ["silk"]

MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "django.middleware.gzip.GZipMiddleware",  # Add gzip compression for HTML responses
    "whitenoise.middleware.WhiteNoiseMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "simple_history.middleware.HistoryRequestMiddleware",  # Track user in history
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]

# Add django_browser_reload middleware only in DEBUG mode
if DEBUG and "django_browser_reload" in INSTALLED_APPS:
    MIDDLEWARE += ["django_browser_reload.middleware.BrowserReloadMiddleware"]
    INTERNAL_IPS = [
        "127.0.0.1",
    ]

# Silk profiling middleware (must come after GZipMiddleware)
if ENABLE_SILK:
    MIDDLEWARE += ["silk.middleware.SilkyMiddleware"]

ROOT_URLCONF = "UniRV_Django.urls"


# Custom context processor to make HAS_THUMBNAILS and DEBUG available in templates
def template_context(request):
    return {
        "HAS_THUMBNAILS": HAS_THUMBNAILS,
        "DEBUG": DEBUG,
    }


TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [BASE_DIR / "templates"],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
                "UniRV_Django.settings.template_context",
            ],
        },
    },
]

WSGI_APPLICATION = "UniRV_Django.wsgi.application"


# Database
# Uses DATABASE_URL environment variable. SQLite for local, PostgreSQL for production
database_url = env("DATABASE_URL")
if database_url:
    DATABASES = {"default": env.db("DATABASE_URL", default=database_url)}
    # Connection pooling for PostgreSQL (no effect on SQLite)
    if "postgres" in database_url:
        DATABASES["default"]["CONN_MAX_AGE"] = 600
        DATABASES["default"]["CONN_HEALTH_CHECKS"] = True
else:
    from django.core.exceptions import ImproperlyConfigured

    raise ImproperlyConfigured(
        "DATABASE_URL environment variable is required. "
        "Local: DATABASE_URL=sqlite:///db.sqlite3 "
        "Production: DATABASE_URL=postgresql://user:password@host:5432/dbname"
    )


# Password validation
# https://docs.djangoproject.com/en/5.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.2/topics/i18n/

LANGUAGE_CODE = "pt-br"

TIME_ZONE = "America/Sao_Paulo"

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.2/howto/static-files/

STATIC_URL = "/static/"

STATICFILES_DIRS = [
    BASE_DIR / "static",
]

STATIC_ROOT = BASE_DIR / "staticfiles"

# Media files (user-uploaded content)
MEDIA_ROOT = BASE_DIR / "media"

# CDN Configuration for Image Delivery (Optional)
#
# Configure CDN_BASE_URL to serve images via CDN (Cloudflare Images, Cloudinary, Imgix, etc.)
# If not set, images will be served via Django static files.
#
# Example CDN configurations:
#   Cloudflare Images: CDN_BASE_URL = "https://imagedelivery.net/your-account-id"
#   Cloudinary: CDN_BASE_URL = "https://res.cloudinary.com/your-cloud-name"
#   Imgix: CDN_BASE_URL = "https://your-domain.imgix.net"
#   Custom S3+CloudFront: CDN_BASE_URL = "https://d1234567890.cloudfront.net"
#
# CDN_IMAGE_FORMATS defines the priority order of formats to use.
# Browsers will automatically select the best supported format from the srcset.
CDN_BASE_URL = env("CDN_BASE_URL") or None
CDN_IMAGE_FORMATS = [
    "avif",
    "webp",
    "jpg",
]  # Format priority: AVIF (best) -> WebP -> JPEG (fallback)

# Override MEDIA_URL to use CDN if CDN_BASE_URL is configured
if CDN_BASE_URL:
    # Strip whitespace and trailing slashes from CDN_BASE_URL
    cdn_url = CDN_BASE_URL.strip().rstrip("/")
    MEDIA_URL = f"{cdn_url}/media/"
else:
    MEDIA_URL = "/media/"

# Production warning: Media files should be served by web server (nginx/apache), not Django
if not DEBUG:
    import warnings

    warnings.warn(
        "Ensure MEDIA_ROOT is served by your web server (nginx/apache), not Django. "
        "User-uploaded files should never be executed.",
        UserWarning,
    )

# Easy Thumbnails configuration
# Thumbnails are generated on-demand and cached for performance
# Using max dimensions instead of fixed size to preserve aspect ratio
# crop=False prevents cutting logos, upscale=False prevents enlarging small images
THUMBNAIL_ALIASES = {
    "": {
        "card_thumb": {
            "size": (150, 150),  # Max dimensions, not fixed
            "crop": False,  # Don't crop - preserve aspect ratio
            "upscale": False,  # Don't enlarge small images
            "quality": 85,
        },
        "detail_thumb": {
            "size": (256, 256),  # Max dimensions, not fixed
            "crop": False,  # Don't crop - preserve aspect ratio
            "upscale": False,  # Don't enlarge small images
            "quality": 90,
        },
        "hero_thumb": {
            "size": (128, 128),  # Max dimensions, not fixed
            "crop": False,  # Don't crop - preserve aspect ratio
            "upscale": False,  # Don't enlarge small images
            "quality": 85,
        },
    },
}

# Thumbnail storage: use same storage as media files
# Thumbnails will be stored in MEDIA_ROOT/thumbnails/ by default
# If you need custom location, uncomment and set:
# THUMBNAIL_ROOT = MEDIA_ROOT / 'thumbnails'
# THUMBNAIL_BASEDIR = 'thumbnails'

# Tailwind CSS configuration
TAILWIND_APP_NAME = "theme"

# NPM binary path (auto-detected with overrides for portability)
NPM_BIN_PATH = (
    env("NPM_BIN_PATH") or shutil.which("npm") or shutil.which("npm.cmd") or "npm"
)

# Disable Tailwind CSS compilation on-the-fly in development
TAILWIND_COMPILE_ON_THE_FLY = env("TAILWIND_COMPILE_ON_THE_FLY")

# Static files finders
STATICFILES_FINDERS = [
    "django.contrib.staticfiles.finders.FileSystemFinder",
    "django.contrib.staticfiles.finders.AppDirectoriesFinder",
]

# WhiteNoise: serve compressed static files
# Use non-manifest storage during tests to avoid requiring collected static files
# In development, use simple storage to avoid slow manifest lookups
if TESTING:
    STORAGES = {
        "default": {
            "BACKEND": "django.core.files.storage.FileSystemStorage",
        },
        "staticfiles": {
            "BACKEND": "django.contrib.staticfiles.storage.StaticFilesStorage",
        },
    }
elif DEBUG:
    # Development: Use simple storage for faster static file serving
    # CompressedManifestStaticFilesStorage is slow because it checks manifest on every request
    STORAGES = {
        "default": {
            "BACKEND": "django.core.files.storage.FileSystemStorage",
        },
        "staticfiles": {
            "BACKEND": "whitenoise.storage.CompressedStaticFilesStorage",
        },
    }
else:
    # Production: Use manifest storage for cache busting
    # ForgivingManifestStaticFilesStorage: falls back to unhashed URL if a file is
    # missing from the manifest instead of crashing with a 500 error.  This makes
    # deploys resilient to minor static-file mismatches while still providing
    # cache-busting for all files that *are* in the manifest.
    STORAGES = {
        "default": {
            "BACKEND": "django.core.files.storage.FileSystemStorage",
        },
        "staticfiles": {
            "BACKEND": "editais.storage.ForgivingManifestStaticFilesStorage",
        },
    }

# Static files caching headers
# Set cache headers for both development and production
# Development: 1 hour cache for testing, Production: 1 year
# For Lighthouse testing, use longer cache even in development
# Note: CompressedManifestStaticFilesStorage automatically adds cache headers
# To test with longer cache in development, set: WHITENOISE_MAX_AGE=31536000
if DEBUG:
    # Allow override via environment variable for Lighthouse testing
    _whitenoise_env = env("WHITENOISE_MAX_AGE")
    if _whitenoise_env:
        WHITENOISE_MAX_AGE = _whitenoise_env
    else:
        WHITENOISE_MAX_AGE = 3600  # 1 hour in seconds for development
else:
    WHITENOISE_MAX_AGE = 31536000  # 1 year in seconds for production

# WhiteNoise compression settings
WHITENOISE_USE_FINDERS = (
    DEBUG  # Only use finders in dev; production serves from STATIC_ROOT
)
WHITENOISE_AUTOREFRESH = DEBUG  # Auto-refresh in development mode
WHITENOISE_MANIFEST_STRICT = (
    False  # Don't fail if manifest file is missing (useful in dev)
)

# Cache configuration
# Redis is the primary cache backend. Falls back to LocMemCache only if Redis
# is not configured (no REDIS_URL / REDIS_HOST env vars).
# Cache versioning: increment CACHE_VERSION env var to force cache purge on deploys.
CACHE_VERSION = env("CACHE_VERSION")

redis_url = env("REDIS_URL")
redis_host = env("REDIS_HOST")
redis_port = env("REDIS_PORT")
redis_password = env("REDIS_PASSWORD")

if redis_url:
    redis_location = redis_url
    # Derive sessions location by switching to DB 2 (if URL ends with /N pattern)
    # If REDIS_URL already specifies a DB, sessions will use DB+1
    redis_sessions_location = redis_url.rstrip("/").rsplit("/", 1)
    if len(redis_sessions_location) == 2 and redis_sessions_location[1].isdigit():
        _base = redis_sessions_location[0]
        _db = int(redis_sessions_location[1])
        redis_sessions_location = f"{_base}/{_db + 1}"
    else:
        redis_sessions_location = f"{redis_url.rstrip('/')}/2"
elif redis_host:
    _auth = f":{redis_password}@" if redis_password else ""
    redis_location = f"redis://{_auth}{redis_host}:{redis_port}/1"
    redis_sessions_location = f"redis://{_auth}{redis_host}:{redis_port}/2"
else:
    redis_location = ""
    redis_sessions_location = ""

if redis_location:
    _redis_options = {
        "CLIENT_CLASS": "django_redis.client.DefaultClient",
        "SOCKET_CONNECT_TIMEOUT": 5,
        "SOCKET_TIMEOUT": 5,
        "CONNECTION_POOL_KWARGS": {
            "max_connections": env("REDIS_MAX_CONNECTIONS"),
            "retry_on_timeout": True,
        },
        "IGNORE_EXCEPTIONS": not DEBUG,
    }
    CACHES = {
        "default": {
            "BACKEND": "django_redis.cache.RedisCache",
            "LOCATION": redis_location,
            "OPTIONS": _redis_options,
            "KEY_PREFIX": "unirv_editais",
            "TIMEOUT": 300,
            "VERSION": CACHE_VERSION,
        },
        "sessions": {
            "BACKEND": "django_redis.cache.RedisCache",
            "LOCATION": redis_sessions_location,
            "OPTIONS": _redis_options,
            "KEY_PREFIX": "unirv_sessions",
            "TIMEOUT": 1209600,  # 2 weeks
            "VERSION": CACHE_VERSION,
        },
    }
    SESSION_ENGINE = "django.contrib.sessions.backends.cache"
    SESSION_CACHE_ALIAS = "sessions"
else:
    # Fallback: LocMemCache when Redis is not configured
    if not DEBUG:
        import warnings

        warnings.warn(
            "Redis is not configured (REDIS_URL or REDIS_HOST not set). "
            "Using LocMemCache — not suitable for multi-process production deployments.",
            UserWarning,
        )
    CACHES = {
        "default": {
            "BACKEND": "django.core.cache.backends.locmem.LocMemCache",
            "LOCATION": "unique-snowflake",
            "OPTIONS": {"MAX_ENTRIES": 1000},
            "VERSION": CACHE_VERSION,
        }
    }

# Add Redis health check only when Redis is configured (avoids failures when using SQLite/LocMemCache)
if redis_location:
    INSTALLED_APPS.append("health_check.contrib.redis")

# Default primary key field type
# https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"

# Cookie domain validation
_cookie_domain = env("COOKIE_DOMAIN")
if _cookie_domain and not _cookie_domain.startswith("."):
    import warnings

    warnings.warn(
        f"COOKIE_DOMAIN '{_cookie_domain}' should start with '.' for subdomain support. "
        f"Example: .yourdomain.com (not yourdomain.com)",
        UserWarning,
    )

# Login URL for @login_required decorator
LOGIN_URL = "/login/"
LOGIN_REDIRECT_URL = "/dashboard/home/"

# Application-specific settings
EDITAIS_PER_PAGE = 12  # Number of editais to display per page
EDITAIS_CACHE_TTL = 300  # Cache TTL for index pages (5 minutes in seconds)
EDITAL_SEARCH_FIELDS = [
    "titulo",
    "entidade_principal",
    "numero_edital",
    "analise",
    "objetivo",
    "etapas",
    "recursos",
    "itens_financiaveis",
    "criterios_elegibilidade",
    "criterios_avaliacao",
    "itens_essenciais_observacoes",
    "detalhes_unirv",
]

# Home page partners marquee (configurable via PARTNERS env: comma-separated, e.g. PARTNERS="SENAI,SEBRAE,FAPEG")
_partners_env = env("PARTNERS")
PARTNERS = (
    [p.strip() for p in _partners_env if p.strip()]
    if _partners_env
    else ["SENAI", "SEBRAE", "FAPEG", "FINEP", "UNIRV", "INOVALAB"]
)

# Security settings for production
#
# Production security is automatically enabled when:
#   1. DEBUG=False (explicitly set via DJANGO_DEBUG=False)
#   2. ALLOWED_HOSTS is configured with valid host(s)
#
# This ensures security settings are only enabled in actual production environments,
# not accidentally in development with DEBUG=False.
#
# Verificar se estamos em produção (DEBUG=False E ALLOWED_HOSTS válido e não-vazio)
# Alinhar com a validação do ALLOWED_HOSTS para evitar ativar segurança de produção
# com configuração inválida (ex: ALLOWED_HOSTS=' ' ou ALLOWED_HOSTS=',,,')
allowed_hosts_env_raw = os.environ.get("ALLOWED_HOSTS", "").strip()
has_valid_allowed_hosts = (
    allowed_hosts_env_raw
    and len([host.strip() for host in allowed_hosts_env_raw.split(",") if host.strip()])
    > 0
)
is_production = not DEBUG and has_valid_allowed_hosts

if is_production:
    # Session security
    SESSION_COOKIE_SECURE = True
    CSRF_COOKIE_SECURE = True
    SECURE_SSL_REDIRECT = True

    # HSTS settings
    SECURE_HSTS_SECONDS = 31536000  # 1 year
    SECURE_HSTS_INCLUDE_SUBDOMAINS = True
    SECURE_HSTS_PRELOAD = True

    # Additional security headers
    SECURE_BROWSER_XSS_FILTER = True
    SECURE_CONTENT_TYPE_NOSNIFF = True
    X_FRAME_OPTIONS = "DENY"
    SECURE_REFERRER_POLICY = "strict-origin-when-cross-origin"
    SECURE_CROSS_ORIGIN_OPENER_POLICY = "same-origin"
else:
    # Development: disable security features that require HTTPS
    SESSION_COOKIE_SECURE = False
    CSRF_COOKIE_SECURE = False
    SECURE_SSL_REDIRECT = False
    # Desabilitar HSTS completamente em desenvolvimento
    SECURE_HSTS_SECONDS = 0
    SECURE_HSTS_INCLUDE_SUBDOMAINS = False
    SECURE_HSTS_PRELOAD = False

# Railway-specific: trust proxy headers and avoid internal HTTPS redirects
_is_railway = any(
    os.environ.get(var)
    for var in ("RAILWAY_ENVIRONMENT", "RAILWAY_ENVIRONMENT_NAME", "RAILWAY_PROJECT_ID")
)
if _is_railway:
    SECURE_PROXY_SSL_HEADER = ("HTTP_X_FORWARDED_PROTO", "https")
    SECURE_SSL_REDIRECT = False

    if "CSRF_TRUSTED_ORIGINS" not in globals():
        CSRF_TRUSTED_ORIGINS = []

    for host in ALLOWED_HOSTS:
        if host not in ["localhost", "127.0.0.1", "[::1]"]:
            origin = f"https://{host}"
            if origin not in CSRF_TRUSTED_ORIGINS:
                CSRF_TRUSTED_ORIGINS.append(origin)

# Session security settings (apply to both dev and production)
SESSION_COOKIE_AGE = 3600  # 1 hour in seconds
SESSION_SAVE_EVERY_REQUEST = True  # Extend session on each request
SESSION_EXPIRE_AT_BROWSER_CLOSE = True  # Expire when browser closes
SESSION_COOKIE_HTTPONLY = True  # Prevent JavaScript access to session cookie
SESSION_COOKIE_SAMESITE = "Lax"  # CSRF protection
# Always store Django messages in the session (avoids cookie-only storage)
MESSAGE_STORAGE = "django.contrib.messages.storage.session.SessionStorage"

# Session cookie domain (prevent session fixation attacks across subdomains)
if not DEBUG:
    cookie_domain = env("COOKIE_DOMAIN")
    if cookie_domain:
        SESSION_COOKIE_DOMAIN = cookie_domain
        CSRF_COOKIE_DOMAIN = cookie_domain

# Email configuration
EMAIL_BACKEND = env("EMAIL_BACKEND")
EMAIL_HOST = env("EMAIL_HOST")
EMAIL_PORT = env("EMAIL_PORT")
EMAIL_USE_TLS = env("EMAIL_USE_TLS")
EMAIL_HOST_USER = env("EMAIL_HOST_USER")
EMAIL_HOST_PASSWORD = env("EMAIL_HOST_PASSWORD")
DEFAULT_FROM_EMAIL = env("DEFAULT_FROM_EMAIL")
SERVER_EMAIL = DEFAULT_FROM_EMAIL

# django-anymail (MailerSend) — only configured when using anymail backend
_mailersend_token = env("MAILERSEND_API_TOKEN")
_anymail_webhook_secret = env("ANYMAIL_WEBHOOK_SECRET")
if "anymail" in EMAIL_BACKEND:
    ANYMAIL = {
        "MAILERSEND_API_TOKEN": _mailersend_token,
    }
    if _anymail_webhook_secret:
        ANYMAIL["WEBHOOK_SECRET"] = _anymail_webhook_secret

# Celery feature flag — controls whether email tasks use Celery or threads
USE_CELERY = env("USE_CELERY")

# Email backend validation and fallback
if not DEBUG and EMAIL_BACKEND == "django.core.mail.backends.smtp.EmailBackend":
    # Validate SMTP settings only for the SMTP backend
    if not EMAIL_HOST_USER or not EMAIL_HOST_PASSWORD:
        import warnings

        warnings.warn(
            "SMTP email not fully configured. Missing EMAIL_HOST_USER or EMAIL_HOST_PASSWORD. "
            "Password reset and notifications won't work.",
            UserWarning,
        )
        EMAIL_BACKEND = "django.core.mail.backends.console.EmailBackend"

# Site URL for email links
SITE_URL = env("SITE_URL")

# Logging configuration
LOG_TO_FILE = env("DJANGO_LOG_TO_FILE")
_log_dir_env = env("DJANGO_LOG_DIR")
LOG_DIR = Path(_log_dir_env) if _log_dir_env else BASE_DIR / "logs"

LOGGING = {
    "version": 1,
    "disable_existing_loggers": False,
    "formatters": {
        "verbose": {
            "format": "{levelname} {asctime} {module} {process:d} {thread:d} {message}",
            "style": "{",
        },
        "structured": {
            "format": "{levelname} {asctime} {name} {message}",
            "style": "{",
        },
    },
    "handlers": {
        "console": {
            "class": "logging.StreamHandler",
            "formatter": "structured",
        },
    },
    "root": {
        "handlers": ["console"],
        "level": "INFO",
    },
    "loggers": {
        "django": {
            "handlers": ["console"],
            "level": env("DJANGO_LOG_LEVEL"),
            "propagate": False,
        },
        "editais": {
            "handlers": ["console"],
            "level": "INFO",
            "propagate": False,
        },
        "django.security": {
            "handlers": ["console"],
            "level": "WARNING",
            "propagate": False,
        },
        "django.db.backends": {
            "handlers": ["console"],
            "level": "DEBUG" if DEBUG else "INFO",
            "propagate": False,
        },
    },
}

if LOG_TO_FILE:
    try:
        LOG_DIR.mkdir(parents=True, exist_ok=True)
        # Test write permissions
        test_file = LOG_DIR / ".write_test"
        test_file.touch()
        test_file.unlink()
    except (OSError, PermissionError) as e:
        import warnings

        warnings.warn(
            f"Cannot write to LOG_DIR ({LOG_DIR}): {e}. "
            "Falling back to console logging.",
            UserWarning,
        )
        LOG_TO_FILE = False

    if LOG_TO_FILE:
        LOGGING["handlers"].update(
            {
                "file": {
                    "class": "logging.handlers.RotatingFileHandler",
                    "filename": LOG_DIR / "django.log",
                    "maxBytes": 10 * 1024 * 1024,  # 10MB
                    "backupCount": 5,
                    "formatter": "verbose",
                },
                "security_file": {
                    "class": "logging.handlers.RotatingFileHandler",
                    "filename": LOG_DIR / "security.log",
                    "maxBytes": 10 * 1024 * 1024,  # 10MB
                    "backupCount": 10,
                    "formatter": "verbose",
                },
                "performance_file": {
                    "class": "logging.handlers.RotatingFileHandler",
                    "filename": LOG_DIR / "performance.log",
                    "maxBytes": 10 * 1024 * 1024,  # 10MB
                    "backupCount": 5,
                    "formatter": "verbose",
                },
            }
        )
        LOGGING["loggers"]["django"]["handlers"].append("file")
        LOGGING["loggers"]["editais"]["handlers"].append("file")
        LOGGING["loggers"]["django.security"]["handlers"] = ["security_file", "console"]
        LOGGING["loggers"]["django.db.backends"]["handlers"] = (
            ["performance_file"] if not DEBUG else ["console"]
        )

# ---------------------------------------------------------------------------
# Celery configuration
# ---------------------------------------------------------------------------
# Derive broker/result backend from env, falling back to the Redis URL used for cache.
_celery_redis_fallback = redis_url or (
    f"redis://{(':' + redis_password + '@') if redis_password else ''}"
    f"{redis_host}:{redis_port}/0"
    if redis_host
    else ""
)

CELERY_BROKER_URL = env("CELERY_BROKER_URL") or _celery_redis_fallback
CELERY_RESULT_BACKEND = env("CELERY_RESULT_BACKEND") or _celery_redis_fallback
CELERY_TIMEZONE = TIME_ZONE
CELERY_ENABLE_UTC = True  # Store internally in UTC, convert to TIME_ZONE for display
CELERY_ACCEPT_CONTENT = ["json"]
CELERY_TASK_SERIALIZER = "json"
CELERY_RESULT_SERIALIZER = "json"
CELERY_TASK_TRACK_STARTED = True
CELERY_TASK_TIME_LIMIT = 300  # 5 minutes hard limit
CELERY_TASK_SOFT_TIME_LIMIT = 240  # 4 minutes soft limit (raises SoftTimeLimitExceeded)
CELERY_WORKER_MAX_TASKS_PER_CHILD = 1000  # Recycle workers to prevent memory leaks
CELERY_BROKER_CONNECTION_RETRY_ON_STARTUP = True

# Default retry policy for tasks
CELERY_TASK_DEFAULT_RETRY_DELAY = 60  # 1 minute
CELERY_TASK_MAX_RETRIES = 3

# django-celery-beat — use the DB scheduler
CELERY_BEAT_SCHEDULER = "django_celery_beat.schedulers:DatabaseScheduler"

# During tests, execute tasks synchronously (no broker needed)
if TESTING:
    CELERY_TASK_ALWAYS_EAGER = True
    CELERY_TASK_EAGER_PROPAGATES = True

# ---------------------------------------------------------------------------
# Silk profiling settings
# ---------------------------------------------------------------------------
if ENABLE_SILK:
    SILKY_PYTHON_PROFILER = True
    SILKY_PYTHON_PROFILER_BINARY = True
    SILKY_MAX_RECORDED_REQUESTS = 10_000
    SILKY_MAX_RECORDED_REQUESTS_CHECK_PERCENT = 10
    SILKY_AUTHENTICATION = True  # Require login
    SILKY_AUTHORISATION = True  # Require staff/superuser
    SILKY_META = True
